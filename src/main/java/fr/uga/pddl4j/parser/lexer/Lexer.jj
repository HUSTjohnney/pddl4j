/*
 * Copyright (c) 2010 by Damien Pellier <Damien.Pellier@imag.fr>.
 *
 * This file is part of PDDL4J library.
 *
 * PDDL4J is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PDDL4J is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PDDL4J.  If not, see <http://www.gnu.org/licenses/>
 */

options {
    STATIC=false;
    IGNORE_CASE=true;
}

PARSER_BEGIN(Lexer)

package fr.uga.pddl4j.parser.lexer;

import fr.uga.pddl4j.parser.ErrorManager;
import fr.uga.pddl4j.parser.ParsedProblem;
import fr.uga.pddl4j.parser.PDDLConnective;
import fr.uga.pddl4j.parser.PDDLDerivedPredicate;
import fr.uga.pddl4j.parser.PDDLParser;
import fr.uga.pddl4j.parser.PDDLExpression;
import fr.uga.pddl4j.parser.PDDLDomain;
import fr.uga.pddl4j.parser.PDDLProblem;
import fr.uga.pddl4j.parser.PDDLNamedTypedList;
import fr.uga.pddl4j.parser.PDDLAction;
import fr.uga.pddl4j.parser.PDDLMethod;
import fr.uga.pddl4j.parser.PDDLRequireKey;
import fr.uga.pddl4j.parser.PDDLSymbol;
import fr.uga.pddl4j.parser.PDDLTaskNetwork;
import fr.uga.pddl4j.parser.PDDLTimeSpecifier;
import fr.uga.pddl4j.parser.PDDLTypedSymbol;
import fr.uga.pddl4j.parser.SymbolType;

import java.io.File;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Lexer {

	private static final int PRIMITIVE_TYPE = 0;
	private static final int VARIABLE = 1;
	private static final int CONSTANT = 2;
	private static final int TERM = 3;
	private static final int ATOMIC_FUNCTION_SKELETON = 4;
	private static final int PARSER_DOMAIN = 5;
	private static final int PARSER_PROBLEM = 6;

	private PDDLDomain domain = null;
	public PDDLDomain getDomain() { return this.domain; }

	private PDDLProblem problem = null;
	public PDDLProblem getProblem() { return this.problem; }

    private File file;
	public File getFile() { return this.file; }
	public void setFile(File file) { this.file = file; }

	private ErrorManager mgr;
	public ErrorManager getErrorManager() { return this.mgr; }
	public void setErrorManager(ErrorManager mgr) { this.mgr = mgr; }

	private void error(Throwable e, int line, int column) {
		String message = new String();
		if (e.getClass().equals(TokenMgrError.class)) {
			String[] tmp = e.getMessage().split(" ");
			int l = -1;
			int c = -1;
			int i = 0;
  			for (i = 0 ; i < tmp.length; i++) {
  				if (tmp[i].equals("line") && i+1 < tmp.length) {
  					l = Integer.parseInt(tmp[i+1].substring(0, tmp[i+1].length()-1));
  				}
  				if (tmp[i].equals("column") && i+1 < tmp.length) {
  					c = Integer.parseInt(tmp[i+1].substring(0, tmp[i+1].length()-1));
  				}
  			}
			message = e.getMessage().split(".  ")[1];
			this.mgr.logLexicalError(message, this.file, l, c);
		} else if (e.getClass().equals(ParseException.class)) {
  			ParseException pe = (ParseException) e;
  			message = generateErrorMesssage(pe);
  			this.mgr.logLexicalError(message, this.file,
  				pe.currentToken.beginLine, pe.currentToken.beginColumn);
  		}
  		this.skipToNextBlock();
	}

	public boolean isRequirement(PDDLRequireKey key) {
		if (domain != null && this.problem != null) {
			return this.domain.getRequirements().contains(key)
			|| this.problem.getRequirements().contains(key);
		} else if (domain != null && this.problem == null) {
			return this.domain.getRequirements().contains(key);
		} else if (problem != null && this.domain == null) {
			return this.problem.getRequirements().contains(key);
		} else {
			return false;
		}
	}

	public Set<PDDLRequireKey> getRequirements() {
		return this.domain.getRequirements();
	}

	private void skipToNextBlock() {
		Token t1;
		Token t2;
		do {
  			t1 = getNextToken();
  			t2 = getToken(2);
  		} while (t1.kind != EOF
  			&& t2 != null
	  		&& t2.kind != REQUIREMENTS
	  		&& t2.kind != PREDICATES
	  		&& t2.kind != TYPES
	  		&& t2.kind != CONSTANTS
	  		&& t2.kind != FUNCTIONS
	  		&& t2.kind != ACTION
	  		&& t2.kind != DURATIVE_ACTION
	  		&& t2.kind != DERIVED
	  		&& t2.kind != OBJECTS
	  		&& t2.kind != INIT
	  		&& t2.kind != GOAL
  			&& t2.kind != METRIC
  			&& t2.kind != EOF);
	}

	private String generateErrorMesssage(ParseException pe) {
        StringBuffer expected = new StringBuffer();
        boolean expectedSeq = false;
        int maxSize = 0;
        for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
            if (maxSize < pe.expectedTokenSequences[i].length) {
                maxSize = pe.expectedTokenSequences[i].length;
            }
            for (int j = 0; j < pe.expectedTokenSequences[i].length; j++) {
                expected.append(pe.tokenImage[pe.expectedTokenSequences[i][j]]).append(" ");
                expectedSeq = true;
            }
            if (pe.expectedTokenSequences[i][pe.expectedTokenSequences[i].length - 1] != 0) {
                expected.append("...");
            }
            if (i < pe.expectedTokenSequences.length - 1) {
                expected.append("\n").append("    ");
            }
        }
        String retval = "unexpected token \"" + pe.currentToken.next.image + "\".";
        if (expectedSeq) {
        	if (pe.expectedTokenSequences.length == 1) {
            	retval += "\nWas expecting:" + "\n" + "    ";
        	} else {
            	retval += "\nWas expecting one of:" + "\n" + "    ";
        	}
        	retval += expected.toString();
        }
        return retval;
    }

}

PARSER_END(Lexer)


SKIP :
{
	" "
| 	"\t"
|	"\n"
| 	"\r"
}
MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
|	";" : IN_SINGLE_LINE_COMMENT
|	<"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|	"/*" : IN_MULTI_LINE_COMMENT
}
<IN_SINGLE_LINE_COMMENT>
	SPECIAL_TOKEN : {
		<SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
	}
<IN_FORMAL_COMMENT>
	SPECIAL_TOKEN :	{
		<FORMAL_COMMENT: "*/" > : DEFAULT
	}
<IN_MULTI_LINE_COMMENT>
	SPECIAL_TOKEN : {
		<MULTI_LINE_COMMENT: "*/" > : DEFAULT
	}
<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
	MORE : {
		< ~[] >
}

TOKEN :
{
  	< LEFT_BRACKET: "(">
| 	< RIGHT_BRACKET: ")">
|   < ALIAS : "@" >
}

TOKEN : {
	< DEFINE : "define" >
|	< DOMAIN : "domain" >
|	< REQUIREMENTS : ":requirements" >
|	< TYPES : ":types" >
|	< EITHER : "either" >
|	< CONSTANTS : ":constants" >
|	< PREDICATES : ":predicates" >
|	< FUNCTIONS : ":functions" >
|	< ACTION : ":action" >
|	< PARAMETERS : ":parameters" >
|	< PRECONDITION : ":precondition" >
|	< EFFECT : ":effect" >
|	< PREFERENCE : "preference" >
|	< WHEN : "when" >
|	< DURATIVE_ACTION : ":durative-action" >
|	< DURATION : ":duration" >
|	< CONDITION : ":condition" >
|	< DERIVED : ":derived" >
|	< PROBLEM : "problem" >
|	< P_DOMAIN : ":domain" >
|	< OBJECTS	: ":objects" >
|	< INIT : ":init" >
|	< GOAL: ":goal" >
|	< METRIC : ":metric" >
|   < METHOD : ":method" > // ADD HDDL
|   < TASK : ":task" > // ADD HDDL
|   < ORDERED_SUBTASKS : ":ordered-subtasks" > // ADD HDDL
|   < ORDERED_TASKS : ":ordered-tasks" > // ADD HDDL
|   < TASKS : ":tasks" > // ADD HDDL
|   < SUBTASKS : ":subtasks" > // ADD HDDL
|   < ORDERING : ":ordering" > // ADD HDDL
|	< DURATIVE_METHOD : ":durative-method" > // ADD HDDL2.1
}

TOKEN : {
	< STRIPS : ":strips" >
|	< TYPING : ":typing" >
|	< NEGATIVE_PRECONDITIONS : ":negative-preconditions" >
|	< DISJUNCTIVE_PRECONDITIONS : ":disjunctive-preconditions" >
|	< EQUALITY : ":equality" >
|	< EXISTENTIAL_PRECONDITIONS : ":existential-preconditions" >
|	< UNIVERSAL_PRECONDITIONS : ":universal-preconditions" >
|	< QUANTIFIED_PRECONDITIONS : ":quantified-preconditions" >
|	< CONDITIONAL_EFFECTS : ":conditional-effects" >
|	< ACTION_COSTS : ":action-costs" >
|   < FLUENTS : ":fluents" >
|   < NUMERIC_FLUENTS : ":numeric-fluents" >
|   < OBJECT_FLUENTS : ":object-fluents" >
|   < GOAL_UTILITIES : ":goal-utilities" >
|	< ADL : ":adl" >
|	< DURATIVE_ACTIONS : ":durative-actions" >
|	< DERIVED_PREDICATES : ":derived-predicates" >
|	< TIMED_INITIAL_LITERALS : ":timed-initial-literals" >
|	< PREFERENCES : ":preferences" >
|	< CONSTRAINTS : ":constraints" >
|	< CONTINUS_EFFECTS : ":continus-effects" >
|	< DURATION_INEQUALITIES : ":duration-inequalities" >
|	< HIERARCHY : ":hierarchy" > // ADD HDDL
|	< HTN : ":htn" > // ADD HDDL
|   < METHOD_PRECONDITIONS : ":method-preconditions" > // ADD HDDL
|   < METHOD_CONSTRAINTS : ":method-constraints" > // ADD HDDL2.1
}

TOKEN :
{
	< GREAT : ">" >
|	< LESS : "<" >
|	< GEQUAL : ">=" >
|	< LEQUAL : "<=" >
|	< EQUAL : "=" >
}

TOKEN :
{
	< MUL : "*" >
|	< DIV : "/" >
|	< ADD : "+" >
|	< SUB : "-" >
}

TOKEN :
{
	<ASSIGN : "assign" >
|	<SCALE_UP : "scale-up" >
|	<SCALE_DOWN : "scale-down" >
|	<INCREASE : "increase" >
|	<DECREASE : "decrease" >
}

TOKEN :
{
    < OR : "or" >
|   < AND : "and" >
|   < IMPLY : "imply" >
| 	< NOT : "not" >
|	< FORALL : "forall" >
|	< EXISTS : "exists" >
}

TOKEN :
{
	< ALWAYS : "always" >
|	< SOMETIME : "sometime" >
|	< WITHIN : "within" >
|	< AT_MOST_ONCE : "at-most-once" >
|	< SOMETIME_AFTER : "sometime-after" >
|	< SOMETIME_BEFORE : "sometime-before" >
|	< ALWAYS_WITHIN : "always-within" >
|	< HOLD_DURING : "hold-during" >
|	< HOLD_AFTER : "hold-after" >
|	< HOLD_BEFORE : "hold-before" >
|	< HOLD_BETWEEN : "hold-between" >
|	< AT: "at" >
|	< START : "start">
|	< END : "end">
|	< OVER : "over">
|	< ALL : "all">
|	< TOTAL_TIME : "total-time" >
|	< TOTAL_COST : "total-cost" >
|	< MAXIMIZE : "maximize" >
|	< MINIMIZE : "minimize" >
|	< IS_VIOLATED : "is-violated" >

}

TOKEN :
{
	< VAR_DURATION : "?duration" >
|	< CONTINUOUS_VARIABLE : "#t" >
|	< F_DURATION : "duration" > // ADD HDDL2.1
}

TOKEN :
{
	< NUMBER_TYPE : "number" >
|	< OBJECT_TYPE : "object" >
}


TOKEN :
{
	< VARIABLE_SYMBOL : ("?" <LETTER> (<LETTER> | <SEPARATOR> | <DIGIT>)*) >
|	< SYMBOL : ((<LETTER> (<LETTER> | "-" | <DIGIT>)*)) >
|	< NUMBER :  (<DIGIT>)+ ("." (<DIGIT>)*)? >
|	< #DIGIT : ["0"-"9"] >
|	< #LETTER : ["a"-"z","A"-"Z","_"] >
|	< #SEPARATOR : ["_","-"] >
}

Token right_bracket() :
{
	Token t = null;
}
{
	t=<RIGHT_BRACKET> { return t;}
}

Token left_bracket() :
{
	Token t = null;
}
{
	t=<LEFT_BRACKET> { return t;}
}

PDDLDomain domain() :
{
	PDDLExpression exp = null;
	PDDLSymbol name = null;
}
{
	try {
		left_bracket() <DEFINE> left_bracket() <DOMAIN>
			name=domain_name() {
				this.domain = new ParsedProblem(name);
			}
		right_bracket()
		[LOOKAHEAD(2) require_def(Lexer.PARSER_DOMAIN)]
		[LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.TYPING)}) type_def() ]
		[LOOKAHEAD(2) constants_def()]
		[LOOKAHEAD(2) predicates_def()]
		[LOOKAHEAD(2, {
			this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.ACTION_COSTS)
		}) functions_def()]
		[LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.CONSTRAINTS)}) pddl_const(Lexer.PARSER_DOMAIN)]
		(structure_def())+
		right_bracket()
		<EOF>
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
	    return this.domain;
    }
}

ParsedProblem domain_and_problem() :
{
	PDDLExpression exp = null;
	PDDLSymbol name = null;
}
{
	try {
    	left_bracket() <DEFINE> left_bracket() <DOMAIN>
            name=domain_name() {
                this.domain = new ParsedProblem(name);
            }
        right_bracket()
        [LOOKAHEAD(2) require_def(Lexer.PARSER_DOMAIN)]
        [LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.TYPING)}) type_def() ]
        [LOOKAHEAD(2) constants_def()]
        [LOOKAHEAD(2) predicates_def()]
        [LOOKAHEAD(2, {
            this.isRequirement(PDDLRequireKey.FLUENTS)
            || this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
            || this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)
            || this.isRequirement(PDDLRequireKey.ACTION_COSTS)
        }) functions_def()]
        [LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.CONSTRAINTS)}) pddl_const(Lexer.PARSER_DOMAIN)]
        (structure_def())+
        right_bracket()
    	//Problem file
    	problem()
    } catch(Throwable e) {
    	this.error(e, token.beginLine, token.beginColumn);
    }
    {
        return new ParsedProblem(this.domain, this.problem);
    }
}

void require_def(int type) :
{
	Token t = null;
	Set<PDDLRequireKey> requirements = null;
	if (type == Lexer.PARSER_DOMAIN) {
		this.domain.addRequirement(PDDLRequireKey.STRIPS);
	}
}
{
	try {
		t=left_bracket() <REQUIREMENTS>
			(requirements=require_key() {
				if (type == Lexer.PARSER_DOMAIN) {
					for (PDDLRequireKey r : requirements) {
						this.domain.addRequirement(r);
					}
				} else {
					for (PDDLRequireKey r : requirements) {
						this.problem.addRequirement(r);
					}
				}
			})+ right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

Set<PDDLRequireKey> require_key() :
{
	Set<PDDLRequireKey> requirements = new LinkedHashSet<PDDLRequireKey>();
}
{
	(	<STRIPS> {
			requirements.add(PDDLRequireKey.STRIPS);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	| 	<TYPING> {
			requirements.add(PDDLRequireKey.TYPING);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	| 	<NEGATIVE_PRECONDITIONS> {
			requirements.add(PDDLRequireKey.NEGATIVE_PRECONDITIONS);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<DISJUNCTIVE_PRECONDITIONS> {
			requirements.add(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<EQUALITY> {
			requirements.add(PDDLRequireKey.EQUALITY);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<EXISTENTIAL_PRECONDITIONS> {
			requirements.add(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS);
			if (requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)) {
				requirements.add(PDDLRequireKey.QUANTIFIED_PRECONDITIONS);
			}
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<UNIVERSAL_PRECONDITIONS> {
			requirements.add(PDDLRequireKey.UNIVERSAL_PRECONDITIONS);
			if (requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)) {
				requirements.add(PDDLRequireKey.QUANTIFIED_PRECONDITIONS);
			}
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<QUANTIFIED_PRECONDITIONS> {
			requirements.add(PDDLRequireKey.QUANTIFIED_PRECONDITIONS);
			requirements.add(PDDLRequireKey.UNIVERSAL_PRECONDITIONS);
			requirements.add(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<CONDITIONAL_EFFECTS> {
			requirements.add(PDDLRequireKey.CONDITIONAL_EFFECTS);
			if (requirements.contains(PDDLRequireKey.STRIPS)
					&& requirements.contains(PDDLRequireKey.TYPING)
					&& requirements.contains(PDDLRequireKey.NEGATIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EQUALITY)
					&& requirements.contains(PDDLRequireKey.QUANTIFIED_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)
					&& requirements.contains(PDDLRequireKey.CONDITIONAL_EFFECTS)) {
				requirements.add(PDDLRequireKey.ADL);
			}
		}
	|	<FLUENTS> {
			requirements.add(PDDLRequireKey.FLUENTS);
			requirements.add(PDDLRequireKey.NUMERIC_FLUENTS);
			requirements.add(PDDLRequireKey.OBJECT_FLUENTS);
		}
	|	<NUMERIC_FLUENTS> {
			requirements.add(PDDLRequireKey.NUMERIC_FLUENTS);
			if (requirements.contains(PDDLRequireKey.OBJECT_FLUENTS)) {
				requirements.add(PDDLRequireKey.FLUENTS);
			}
		}
	|	<OBJECT_FLUENTS> {
			requirements.add(PDDLRequireKey.OBJECT_FLUENTS);
			if (requirements.contains(PDDLRequireKey.NUMERIC_FLUENTS)) {
				requirements.add(PDDLRequireKey.FLUENTS);
			}
		}
	|	<GOAL_UTILITIES> {
			requirements.add(PDDLRequireKey.GOAL_UTILITIES);
		}
	|	<ADL> {
			requirements.add(PDDLRequireKey.ADL);
			requirements.add(PDDLRequireKey.STRIPS);
			requirements.add(PDDLRequireKey.TYPING);
			requirements.add(PDDLRequireKey.NEGATIVE_PRECONDITIONS);
			requirements.add(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS);
			requirements.add(PDDLRequireKey.EQUALITY);
			requirements.add(PDDLRequireKey.UNIVERSAL_PRECONDITIONS);
			requirements.add(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS);
			requirements.add(PDDLRequireKey.CONDITIONAL_EFFECTS);
		}
	|	<ACTION_COSTS> {
			requirements.add(PDDLRequireKey.ACTION_COSTS);
		}
	|	<DURATIVE_ACTIONS> {
			requirements.add(PDDLRequireKey.DURATIVE_ACTIONS);
			requirements.add(PDDLRequireKey.DURATION_INEQUALITIES);
		}
	|	<DERIVED_PREDICATES> {
			requirements.add(PDDLRequireKey.DERIVED_PREDICATES);
		}
	| 	<TIMED_INITIAL_LITERALS> {
			requirements.add(PDDLRequireKey.TIMED_INITIAL_LITERALS);
		}
	|	<PREFERENCES> {
			requirements.add(PDDLRequireKey.PREFERENCES);
		}
	|	<CONSTRAINTS> {
			requirements.add(PDDLRequireKey.CONSTRAINTS);
		}
	|	<CONTINUS_EFFECTS> {
			requirements.add(PDDLRequireKey.CONTINOUS_EFFECTS);
		}
	|	<DURATION_INEQUALITIES> {
			requirements.add(PDDLRequireKey.DURATION_INEQUALITIES);
		}
	|	<HIERARCHY> { // ADD HDDL
    		requirements.add(PDDLRequireKey.HIERARCHY);
        }
    |   <METHOD_PRECONDITIONS> { // ADD HDDL
            requirements.add(PDDLRequireKey.METHOD_PRECONDITIONS);
        }
    |   <METHOD_CONSTRAINTS> { // ADD HDDL 2.1
            requirements.add(PDDLRequireKey.METHOD_CONSTRAINTS);
        }
)
	{ return requirements; }
}


void type_def():
{
	List<PDDLTypedSymbol> typedList = null;
}
{
	try {
		left_bracket() <TYPES>
			typedList=typed_list(Lexer.PRIMITIVE_TYPE)
		right_bracket()  {
			for (PDDLTypedSymbol type : typedList) {
				this.domain.addType(type);
			}
//			for (PDDLTypedSymbol token : this.types_def) {
//				if (token.getTypes().isEmpty()) {
//					token.addType(PDDLParser.OBJECT);
//				}
//			}
		}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

List<PDDLTypedSymbol> typed_list(int kind) :
{
	PDDLSymbol t;
	List<PDDLSymbol> types = null;
	List<PDDLTypedSymbol> typedList = new ArrayList<PDDLTypedSymbol>();
	List<PDDLSymbol> tmp = new ArrayList<PDDLSymbol>();
	List<PDDLTypedSymbol> nextTypedList = null;
}
{
    (   LOOKAHEAD(2)
        left_bracket() right_bracket()
	|   LOOKAHEAD(2, {kind == Lexer.PRIMITIVE_TYPE})
			(t=primitive_type() {
				tmp.add(t);
			})*
			(LOOKAHEAD(1, { this.isRequirement(PDDLRequireKey.TYPING)})
				<SUB> types=type() nextTypedList=typed_list(kind))? {
				if (types == null) {
					types = new ArrayList<PDDLSymbol>();
				}
				for (PDDLSymbol s : tmp) {
					PDDLTypedSymbol ts = new PDDLTypedSymbol(s);
					for (PDDLSymbol type : types) {
						ts.addType(type);
					}
					typedList.add(ts);
				}
				if (nextTypedList != null) {
					typedList.addAll(nextTypedList);
				}
			}
	|	LOOKAHEAD(2, {kind == Lexer.CONSTANT})
			(t=constant() {
				tmp.add(t);
			})*
			(LOOKAHEAD(1, { this.isRequirement(PDDLRequireKey.TYPING)})
				<SUB> types=type() nextTypedList=typed_list(kind))? {
				if (types == null) {
					types = new ArrayList<PDDLSymbol>();
				}
				for (PDDLSymbol s : tmp) {
					PDDLTypedSymbol ts = new PDDLTypedSymbol(s);
					for (PDDLSymbol type : types) {
						ts.addType(type);
					}
					typedList.add(ts);
				}
				if (nextTypedList != null) {
					typedList.addAll(nextTypedList);
				}
			}
	|	LOOKAHEAD(2, {kind == Lexer.VARIABLE})
			(t=variable() {
				tmp.add(t);
			})*
			(LOOKAHEAD(1, { this.isRequirement(PDDLRequireKey.TYPING)})
				<SUB> types=type() nextTypedList=typed_list(kind))? {
				if (types == null) {
					types = new ArrayList<PDDLSymbol>();
					types.add(PDDLParser.OBJECT);
				}
				for (PDDLSymbol s : tmp) {
					PDDLTypedSymbol ts = new PDDLTypedSymbol(s);
					for (PDDLSymbol type : types) {
						ts.addType(type);
					}
					typedList.add(ts);
				}
				if (nextTypedList != null) {
					typedList.addAll(nextTypedList);
				}
			}
	) {
		return typedList;
	}
}

List<PDDLSymbol> type() :
{
	PDDLSymbol s;
	List<PDDLSymbol> type = new ArrayList<PDDLSymbol>();
}
{
	(	left_bracket() <EITHER>
		(LOOKAHEAD(2) s=primitive_type() {
			type.add(s);
		})+
	right_bracket()
	|	s=primitive_type() {
		type.add(s);
	}) {
		return type;
	}
}

PDDLSymbol primitive_type() :
{
	Token t = token;
}
{
(	t=<OBJECT_TYPE>
|	t=<NUMBER_TYPE>
| 	t=<SYMBOL>)
	{
	return new PDDLSymbol(SymbolType.TYPE, t);
}
}

void constants_def() :
{
	List<PDDLTypedSymbol> typedList = null;
}
{
	try {
		left_bracket() <CONSTANTS>
			typedList=typed_list(Lexer.CONSTANT)
		right_bracket() {
			for (PDDLTypedSymbol constant : typedList) {
				this.domain.addConstant(constant);
			}
		}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

PDDLSymbol constant() :
{
	Token t;
}
{
	(	t=<SYMBOL>
	|	t=<AT>
	| 	t=<END>
	| 	t=<START>
	| 	t=<OVER>) {
	return new PDDLSymbol(SymbolType.CONSTANT, t);
}
}

void predicates_def() :
{
	PDDLNamedTypedList predicate = null;
}
{
	try {
		left_bracket() <PREDICATES>
			(LOOKAHEAD(2) predicate=atomic_formula_skeleton() {
				this.domain.addPredicate(predicate);
			})+
		right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

PDDLNamedTypedList comp_task_def() : // ADD HDDL
{
    PDDLNamedTypedList taskID;
}
{
    left_bracket() <TASK> taskID=task_def() right_bracket() {
        return taskID;
    }
}

PDDLNamedTypedList task_def() : // ADD HDDL
{
    PDDLSymbol name;
    List<PDDLTypedSymbol> typedList = null;
}
{
    name=task_symbol()
    <PARAMETERS>
    left_bracket()
    typedList=typed_list(Lexer.VARIABLE)
    right_bracket() {
        PDDLNamedTypedList l = new PDDLNamedTypedList(name);
        for (PDDLTypedSymbol s : typedList) {
            l.add(s);
        }
        return l;
    }
}

PDDLSymbol task_symbol() : // ADD HDDL
 {
 	Token t = token;
 }
 {
 	t=<SYMBOL> {
 		return new PDDLSymbol(SymbolType.TASK, t);
 	}
 }


PDDLNamedTypedList atomic_formula_skeleton() :
{
	PDDLSymbol predicate = null;
	List<PDDLTypedSymbol> typedList = null;
}
{
	left_bracket()
		predicate=predicate()
		typedList=typed_list(Lexer.VARIABLE)
	right_bracket() {
		PDDLNamedTypedList l = new PDDLNamedTypedList(predicate);
		for (PDDLTypedSymbol s : typedList) {
			l.add(s);
		}
		return l;
	}
}

PDDLSymbol predicate() :
{
	Token t;
}
{
	(t=<SYMBOL>
| 	t=<AT>
| 	t=<END>
| 	t=<START>
| 	t=<OVER>) {
		return new PDDLSymbol(SymbolType.PREDICATE, t);
	}
}

PDDLSymbol variable() :
{
	Token t = token;
}
{
	t=<VARIABLE_SYMBOL> { return new PDDLSymbol(SymbolType.VARIABLE, t); }
}

void functions_def():
{
	List<PDDLNamedTypedList> functions = null;
}
{
	try {
		left_bracket() <FUNCTIONS>
			functions=function_typed_list(Lexer.ATOMIC_FUNCTION_SKELETON)
		right_bracket() {
			for (PDDLNamedTypedList function: functions) {
				this.domain.addFunction(function);
			}
		}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

PDDLNamedTypedList atomic_function_skeleton() :
{
	PDDLSymbol functor = null;
	List<PDDLTypedSymbol> typedList = null;
}
{
	left_bracket()
		functor=functor()
		typedList=typed_list(Lexer.VARIABLE)
	right_bracket()
	{
		PDDLNamedTypedList l = new PDDLNamedTypedList(functor);
		for (PDDLTypedSymbol s : typedList) {
			l.add(s);
		}
		return l;
	}
}

PDDLSymbol functor() :
{
	Token t;
}
{
	( t=<SYMBOL>
	| t=<TOTAL_COST>
	| t=<AT>
	| t=<END>
    | t=<START>
    | t=<OVER>) {
	    return new PDDLSymbol(SymbolType.FUNCTOR, t);
	}
}

List<PDDLNamedTypedList> function_typed_list(int type) :
{
	PDDLNamedTypedList namedTypedList = null;
	List<PDDLNamedTypedList> typedListList = new ArrayList<PDDLNamedTypedList>();
	List<PDDLNamedTypedList> nextNamedTypedList = null;
	List<PDDLSymbol> typeList = null;
}
{
	(LOOKAHEAD(2) namedTypedList=atomic_function_skeleton() {
		typedListList.add(namedTypedList);
	})*
	(<SUB> typeList=function_type() {
			for (PDDLSymbol t : typeList) {
				namedTypedList.addType(t);
			}
		}
		nextNamedTypedList=function_typed_list(type) {
			typedListList.addAll(nextNamedTypedList);
		}
	)?
	{
		// To keep compatibility with PDDL 3.0: if no type is set it is number
		for (PDDLNamedTypedList ntl : typedListList) {
			if (ntl.getTypes().isEmpty()) {
				ntl.addType(PDDLParser.NUMBER);
			}
		}
		return typedListList;
	}
}

List<PDDLSymbol> function_type() :
{
	Token token;
	PDDLSymbol symbol;
	List<PDDLSymbol> typesList = new ArrayList<PDDLSymbol>();
}
{
		LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.ACTION_COSTS)})
		token=<NUMBER_TYPE> {
			typesList.add(new PDDLSymbol(SymbolType.TYPE, token));
			return typesList;
		}
	| 	LOOKAHEAD(2, {(this.isRequirement(PDDLRequireKey.TYPING) && this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS))
        	                    || this.isRequirement(PDDLRequireKey.FLUENTS)})
		    typesList=type() {
		        return typesList;
        }
}

PDDLExpression con_gd() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=and_con_gd()
	|	LOOKAHEAD(2) exp=forall_con_gd()
	|	LOOKAHEAD(2) exp=at_end_con_gd()
	|	LOOKAHEAD(2) exp=always_con_gd()
	|	LOOKAHEAD(2) exp=sometime_con_gd()
	|	LOOKAHEAD(2) exp=within_con_gd()
	|	LOOKAHEAD(2) exp=at_most_once_con_gd()
	|	LOOKAHEAD(2) exp=sometime_after_con_gd()
	|	LOOKAHEAD(2) exp=sometime_before_con_gd()
	|	LOOKAHEAD(2) exp=always_within_con_gd()
	|	LOOKAHEAD(2) exp=hold_during_con_gd()
	|	LOOKAHEAD(2) exp=hold_after_con_gd()
	) {
		return exp;
	}
}

PDDLExpression and_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child = null;
	Token begin = null;
	Token end = null;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=con_gd() {
			conGD.addChild(child);
		})*
	end=right_bracket()
	{
		conGD.setBegin(begin);
		conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression forall_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.FORALL);
	PDDLExpression child = null;
	List<PDDLTypedSymbol> typedList = null;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		child=con_gd()
	end=right_bracket()
	{
		conGD.setQuantifiedVariables(typedList);
		conGD.addChild(child);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression at_end_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression exp = null;
	Token begin = null;
    Token end = null;
}
{
		begin=left_bracket() <AT> <END>
			exp=gd()
		end=right_bracket()
	{
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression always_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.ALWAYS_CONSTRAINT);
	PDDLExpression exp = null;
	Token begin = null;
    Token end = null;

}
{
	begin=left_bracket() <ALWAYS>
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression sometime_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.SOMETIME_CONSTRAINT);
	PDDLExpression exp = null;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <SOMETIME>
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression within_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.WITHIN_CONSTRAINT);
	PDDLExpression exp, time;
    Token begin, end;
}
{
	begin=left_bracket() <WITHIN>
		time=number()
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(time);
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression at_most_once_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.AT_MOST_ONCE_CONSTRAINT);
	PDDLExpression exp;
    Token begin, end;
}
{
	begin=left_bracket() <AT_MOST_ONCE>
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression sometime_after_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.SOMETIME_AFTER_CONSTRAINT);
	PDDLExpression gd1 = null;
	PDDLExpression gd2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <SOMETIME_AFTER>
		gd1=gd()
		gd2=gd()
	end=right_bracket()
	{
		conGD.addChild(gd1);
		conGD.addChild(gd2);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression sometime_before_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.SOMETIME_BEFORE_CONSTRAINT);
	PDDLExpression gd1 = null;
	PDDLExpression gd2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <SOMETIME_BEFORE>
		gd1=gd()
		gd2=gd()
	end=right_bracket()
	{
		conGD.addChild(gd1);
		conGD.addChild(gd2);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression always_within_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.ALWAYS_WITHIN_CONSTRAINT);
	PDDLExpression gd1, gd2, time;
    Token begin, end;
}
{
	begin=left_bracket() <ALWAYS_WITHIN>
		time=number()
		gd1=gd()
		gd2=gd()
	end=right_bracket()
	{
		conGD.addChild(time);
		conGD.addChild(gd1);
		conGD.addChild(gd2);
		return conGD;
	}
}

PDDLExpression hold_during_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.HOLD_DURING_CONSTRAINT);
	PDDLExpression exp, lower, upper;
    Token begin, end;
}
{
	begin=left_bracket() <HOLD_DURING>
		lower=number()
		upper=number()
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(lower);
		conGD.addChild(upper);
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression hold_after_con_gd() :
{
	PDDLExpression conGD = new PDDLExpression(PDDLConnective.HOLD_AFTER_CONSTRAINT);
	PDDLExpression exp, time;
    Token begin, end;
}
{
	begin=left_bracket() <HOLD_AFTER>
		time=number()
		exp=gd()
	end=right_bracket()
	{
		conGD.addChild(time);
		conGD.addChild(exp);
		conGD.setBegin(begin);
        conGD.setEnd(end);
		return conGD;
	}
}

PDDLExpression gd() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2)
			exp=atomic_formula(Lexer.TERM)
	|	LOOKAHEAD(2)
			exp=and_gd()
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)})
			exp=or_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.NEGATIVE_PRECONDITIONS)})
			exp=not_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DISJUNCTIVE_PRECONDITIONS)
				&& this.isRequirement(PDDLRequireKey.NEGATIVE_PRECONDITIONS)})
			exp=imply_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.EXISTENTIAL_PRECONDITIONS)})
			exp=exists_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)})
			exp=forall_gd()
	| 	LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.EQUALITY)})
			exp=equal_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)})
			exp=f_comp()
	) {
		return exp;
	}
}

PDDLExpression equal_gd() :
{
	PDDLExpression exp = null;
}
{
	(LOOKAHEAD(2)
		exp=not_equal_atomic_formula()
|	LOOKAHEAD(2)
		exp=equal_atomic_formula()
	) {
		return exp;
	}
}

PDDLExpression not_equal_atomic_formula() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.NOT);
	PDDLExpression c = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket()
		<NOT>
		c=equal_gd()
	end=right_bracket() {
	 	exp.addChild(c);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression equal_atomic_formula() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.EQUAL_ATOM);
	List<PDDLSymbol> args = new ArrayList<PDDLSymbol>();
	Token t = null;
	PDDLSymbol arg1 = null;
	PDDLSymbol arg2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() t=<EQUAL>
		arg1=term()
		arg2=term()
	end=right_bracket() {
        exp.setSymbol(new PDDLSymbol(SymbolType.FUNCTOR, t));
	 	args.add(arg1);
	 	args.add(arg2);
	 	exp.setArguments(args);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression and_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <AND> (LOOKAHEAD(2) s=gd() {
		exp.addChild(s);
	})*
	end=right_bracket()
	{
        exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression or_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.OR);
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <OR> (LOOKAHEAD(2) s=gd() {
		exp.addChild(s);
	})*
	end=right_bracket()
	{
        exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression not_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.NOT);
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <NOT> s=gd() end=right_bracket()
	{
		exp.addChild(s);
        exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression imply_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.IMPLY);
	PDDLExpression p = null;
	PDDLExpression q = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <IMPLY> p=gd() q=gd() end=right_bracket()
	{
		exp.addChild(p);
		exp.addChild(q);
        exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression exists_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.EXISTS);
	List<PDDLTypedSymbol> typedList = null;
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <EXISTS>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		s=gd()
	end=right_bracket() {
		exp.setQuantifiedVariables(typedList);
		exp.addChild(s);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression forall_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	List<PDDLTypedSymbol> typedList = null;
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		s=gd()
	end=right_bracket() {
		exp.setQuantifiedVariables(typedList);
		exp.addChild(s);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression atomic_formula(int type) :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.ATOM);
	List<PDDLSymbol> args = new ArrayList<PDDLSymbol>();
	PDDLSymbol t = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() t=predicate() {
		exp.setSymbol(t);
	}
	(LOOKAHEAD({ type == Lexer.CONSTANT } ) (t=constant() {
			args.add(t);
		})*
	| LOOKAHEAD({ type == Lexer.TERM }) (t=term() {
			args.add(t);
		})*
	) end=right_bracket() {
		exp.setArguments(args);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLSymbol term() :
{
	PDDLSymbol t = null;
}
{
	(	t=constant()
	|	t=variable()
	) {
		return t;
	}
}

PDDLExpression literal(int type) :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=atomic_formula(type)
	| 	LOOKAHEAD(2) exp=not_atomic_formula(type)
	) {
		return exp;
	}
}

PDDLExpression not_atomic_formula(int type) :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.NOT);
	PDDLExpression s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <NOT>
		s=atomic_formula(type)
	end=right_bracket() {
		exp.addChild(s);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression f_comp() :
{
	PDDLExpression exp = null;
}
{
	exp=binary_comp() {
		return exp;
	}
}

PDDLExpression binary_comp() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=greater_comp()
	|	LOOKAHEAD(2) exp=less_comp()
	|	LOOKAHEAD(2) exp=greater_equal_comp()
	|	LOOKAHEAD(2) exp=less_equal_comp()
	|	LOOKAHEAD(2) exp=equal_comp()
	) {
		return exp;
	}
}

PDDLExpression greater_comp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_COMPARISON);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <GREAT>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression greater_equal_comp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_OR_EQUAL_COMPARISON);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <GEQUAL>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression less_equal_comp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_OR_EQUAL_COMPARISON);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <LEQUAL>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression less_comp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_COMPARISON);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <LESS>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
    	exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression equal_comp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.EQUAL_COMPARISON);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <EQUAL>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
	 	exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression f_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.F_EXP);
	PDDLExpression child = null;
    Token begin = null;
    Token end = null;
}
{
	(	child=number()
	|	LOOKAHEAD(2) child=op()
	|	LOOKAHEAD(2) child=f_head()
	) {
		exp.addChild(child);
		exp.setBeginLine(child.getBeginLine());
		exp.setBeginColumn(child.getBeginColumn());
		exp.setEndLine(child.getEndLine());
        exp.setEndColumn(child.getEndColumn());
		return exp;
	}
}

PDDLExpression number() :
{
	Token t = null;
}
{
	t=<NUMBER>
	{
		PDDLExpression exp = new PDDLExpression(PDDLConnective.NUMBER);
		exp.setValue(Double.parseDouble(t.image));
		exp.setBegin(t);
        exp.setEnd(t);
		return exp;
	}
}

PDDLExpression op() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=binary_operation()
	|	LOOKAHEAD(2) exp=unary_op()
	) {
		return exp;
	}
}

PDDLExpression binary_operation():
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=add_op()
	|	LOOKAHEAD(2) exp=substract_op()
	|	LOOKAHEAD(2) exp=multiply_op()
	|	LOOKAHEAD(2) exp=divide_op()
	) {
		return exp;
	}
}

PDDLExpression add_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.PLUS);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <ADD>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression substract_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MINUS);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <SUB>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression multiply_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MULTIPLICATION);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <MUL>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression divide_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.DIVISION);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <DIV>
		op1=f_exp()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression unary_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.UMINUS);
	PDDLExpression op1 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <SUB>
		op1=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression f_head() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FN_HEAD);
	List<PDDLSymbol> args = new ArrayList<PDDLSymbol>();
	PDDLSymbol s = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() s=functor() {
	    	exp.setSymbol(s);
	    } (LOOKAHEAD(2) s=term() {
	        args.add(s);
	    })*
	end=right_bracket() {
	    exp.setArguments(args);
	    exp.setBegin(begin);
	    exp.setEnd(end);
        return exp;
	}
| 	s=functor() {
        exp.setSymbol(s);
		exp.setArguments(args);
        exp.setBeginLine(s.getBeginLine());
        exp.setBeginColumn(s.getBeginColumn());
        exp.setEndLine(s.getEndLine());
        exp.setEndColumn(s.getEndColumn());
		return exp;
	}
}

void structure_def() :
{
	PDDLAction op = null;
	PDDLMethod meth = null;
	PDDLDerivedPredicate dp = null;
	PDDLNamedTypedList task = null;
}
{
	( 	LOOKAHEAD(2)
			op = action_def() {
				this.domain.addAction(op);
			}
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)})
			op = durative_action_def() {
				this.domain.addAction(op);
			}
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DERIVED_PREDICATES)})
			dp = derived_def() {
				this.domain.addDerivedPredicate(dp);
			}
    |   LOOKAHEAD (2, {this.isRequirement(PDDLRequireKey.HIERARCHY)}) // ADD HDDL
            op = htn_action_def() {
                this.domain.addAction(op);
            }
    |   LOOKAHEAD (2, {this.isRequirement(PDDLRequireKey.HIERARCHY)}) // ADD HDDL
            task = comp_task_def() {
                this.domain.addTask(task);
            }
    |   LOOKAHEAD (2, {this.isRequirement(PDDLRequireKey.HIERARCHY)}) // ADD HDDL
            meth = method_def() {
                this.domain.addMethod(meth);
            }
    |	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS) // ADD HDDL2.1
                && this.isRequirement(PDDLRequireKey.HIERARCHY)})
            meth = durative_method_def() {
            }
	)
}

PDDLMethod method_def() : // ADD HDDL
{
	PDDLSymbol name = null;
	List<PDDLTypedSymbol> parameters = null;
	PDDLExpression taskID = null;
	PDDLExpression precondition = new PDDLExpression(PDDLConnective.AND);
	PDDLTaskNetwork tn = null;
	Token begin = null;
    Token end = null;

}
{
	try {
		begin=left_bracket() <METHOD> name=method_name()
			<PARAMETERS> left_bracket() parameters=typed_list(Lexer.VARIABLE) right_bracket()
			<TASK> taskID=task_formula(Lexer.TERM)
			[LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_PRECONDITIONS)})
			    <PRECONDITION> precondition=pre_gd()
			]
            tn = task_network()
		end=right_bracket()
	} catch(Throwable e) {
	    this.error(e, token.beginLine, token.beginColumn);
	}
	{
		PDDLMethod m = new PDDLMethod(name, parameters, taskID, precondition, tn);
		m.setBegin(begin);
        m.setEnd(end);
        return m;
	}
}

PDDLMethod durative_method_def() : // ADD HDDL2.1
{
    PDDLSymbol name = null;
	List<PDDLTypedSymbol> parameters = null;
	PDDLExpression taskID = null;
	PDDLExpression duration = null;
	PDDLExpression condition = new PDDLExpression(PDDLConnective.AND);
	PDDLTaskNetwork tn = null;
	Token begin = null;
    Token end = null;

}
{
	try {
	    begin=left_bracket() <DURATIVE_METHOD> name=method_name()
	        <PARAMETERS> left_bracket() parameters=typed_list(Lexer.VARIABLE) right_bracket()
			<TASK> taskID=task_formula(Lexer.TERM)
			[<DURATION> duration=method_duration_constraint()]
			[LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_PRECONDITIONS)})
			    <CONDITION> condition=da_gd()
			]
            tn = task_network()
		end=right_bracket()
	} catch(Throwable e) {
        this.error(e, token.beginLine, token.beginColumn);
    }
    {
    	PDDLMethod m = new PDDLMethod(name, parameters, taskID, duration, condition, tn);
    	m.setBegin(begin);
        m.setEnd(end);
        return m;
    }
}

PDDLTaskNetwork task_network() : // ADD HDDL
{
    PDDLExpression tasks = null;
    PDDLExpression ordering = new PDDLExpression(PDDLConnective.AND);
    PDDLExpression constraints = new PDDLExpression(PDDLConnective.AND);
    PDDLTaskNetwork tn = null;
}
{
    LOOKAHEAD (1)
        (<TASKS> | <SUBTASKS>)
        tasks = subtask_def()
   	    [<ORDERING> ordering = htn_ordering_constraints_def()]
   	    [<CONSTRAINTS> constraints = htn_constraints_def()]
   	    {
            return new PDDLTaskNetwork(tasks, ordering, constraints, false);
        }
    | LOOKAHEAD (1)
        (<ORDERED_TASKS> | <ORDERED_SUBTASKS>)
        tasks = subtask_def()
        [<ORDERING> ordering = htn_ordering_constraints_def()]
        [<CONSTRAINTS> constraints = htn_constraints_def()]
        {
            return new PDDLTaskNetwork(tasks, ordering, constraints, true);
        }
}

PDDLSymbol method_name() : // ADD HDDL
{
	Token t = token;
}
{
	t=<SYMBOL> {
		return new PDDLSymbol(SymbolType.ACTION, t);
	}
}

PDDLExpression subtask_def() : // ADD HDDL
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
    PDDLExpression taskID = null;
    Token begin;
    Token end;
}
{
    (   LOOKAHEAD(2)
            taskID=subtask() {
                exp = new PDDLExpression(PDDLConnective.AND);
                exp.addChild(taskID);
                exp.setBeginLine(taskID.getBeginLine());
                exp.setBeginColumn(taskID.getBeginColumn());
                exp.setEndLine(taskID.getEndLine());
                exp.setEndColumn(taskID.getEndColumn());
            }
    |   LOOKAHEAD(2)
            exp=and_subtask()
    |   LOOKAHEAD(3)
            begin=left_bracket() end=right_bracket() {
                exp.setBegin(begin);
                exp.setEnd(end);
            }
    ) {
        return exp;
    }
}

PDDLExpression and_subtask() : // ADD HDDL
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
    PDDLExpression task = null;
    int i = 0;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AND> (LOOKAHEAD (2) task=subtask() {
        exp.addChild(task);
    })*
    end=right_bracket() {
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression subtask() :  // ADD HDDL
{
    PDDLSymbol taskID;
    PDDLExpression task;
    Token begin = null;
    Token end = null;
}
{
    (   LOOKAHEAD(3)
            begin=left_bracket()
                taskID=task_id_symbol()
                task=task_formula(Lexer.TERM)
            end=right_bracket() {
                task.setTaskID(taskID);
                task.setBegin(begin);
                task.setEnd(end);
            }
    |   LOOKAHEAD(2)
            task=task_formula(Lexer.TERM)
    ) {
        return task;
    }
}
PDDLExpression task_formula(int type) : // ADD HDDL
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.TASK);
	List<PDDLSymbol> args = new ArrayList<PDDLSymbol>();
	PDDLSymbol t = null;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() t=task_symbol() {
		exp.setSymbol(t);
	}
	(LOOKAHEAD({ type == Lexer.CONSTANT } ) (t=constant() {
			args.add(t);
		})*
	| LOOKAHEAD({ type == Lexer.TERM }) (t=term() {
			args.add(t);
		})*
	) end=right_bracket() {
		exp.setArguments(args);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression htn_ordering_constraints_def() : // ADD HDDL
{
    PDDLExpression exp = null;
    PDDLExpression taskID = null;
}
{
    (   LOOKAHEAD(2)
            exp=empty_and()
    |   LOOKAHEAD(2)
            taskID=htn_ordering_constraint() {
                exp = new PDDLExpression(PDDLConnective.AND);
                exp.addChild(taskID);
                exp.setBeginLine(taskID.getBeginLine());
                exp.setBeginColumn(taskID.getBeginColumn());
                exp.setEndLine(taskID.getEndLine());
                exp.setEndColumn(taskID.getEndColumn());
            }
    |   LOOKAHEAD(2)
            exp = and_ordering_constraints()
    ) {
        return exp;
    }
}

PDDLExpression and_ordering_constraints() : // ADD HDDL
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
    PDDLExpression ordering = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AND> (ordering = htn_ordering_constraint() {
        exp.addChild(ordering);
    })+ end=right_bracket() {
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression htn_ordering_constraint() : // ADD HDDL
{
    PDDLExpression exp = null;
}
{
    (   LOOKAHEAD(3)
            exp = less_htn_ordering_constraint()
    |   LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)}) // ADD HDDL2.1
            exp = equal_htn_temporal_ordering_constraint()
    |   LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)}) // ADD HDDL2.1
            exp = less_htn_temporal_ordering_constraint()
    |   LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)}) // ADD HDDL2.1
            exp = less_or_equal_htn_temporal_ordering_constraint()
    |   LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)}) // ADD HDDL2.1
            exp = great_htn_temporal_ordering_constraint()
    |   LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)}) // ADD HDDL2.1
            exp = great_or_equal_htn_temporal_ordering_constraint()
    ) {
        return exp;
    }
}

PDDLExpression less_htn_ordering_constraint() : // ADD HDDL
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_ORDERING_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <LESS> id1=task_id() id2=task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression equal_htn_temporal_ordering_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.EQUAL_ORDERING_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <EQUAL> id1=timed_task_id() id2=timed_task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression less_htn_temporal_ordering_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_ORDERING_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <LESS> id1 = timed_task_id() id2 = timed_task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression less_or_equal_htn_temporal_ordering_constraint() : // ADD HDDL2.1
{
     PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_OR_EQUAL_ORDERING_CONSTRAINT);
     PDDLExpression id1 = null;
     PDDLExpression id2 = null;
     Token begin = null;
     Token end = null;
}
{
    begin=left_bracket() <LEQUAL> id1 = timed_task_id() id2 = timed_task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression great_htn_temporal_ordering_constraint() : // ADD HDDL2.1
{
     PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_ORDERING_CONSTRAINT);
     List<PDDLSymbol> tasks = new ArrayList<PDDLSymbol>();
     PDDLExpression id1 = null;
     PDDLExpression id2 = null;
     Token begin = null;
     Token end = null;
}
{
    begin=left_bracket() <GREAT> id1 = timed_task_id() id2 = timed_task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression great_or_equal_htn_temporal_ordering_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_OR_EQUAL_ORDERING_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    Token begin = null;
    Token end = null;

}
{
    begin=left_bracket() <GEQUAL> id1 = timed_task_id() id2 = timed_task_id() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLSymbol task_id_symbol() : // ADD HDDL
{
	Token t = token;
}
{
	t=<SYMBOL> {
		return new PDDLSymbol(SymbolType.TASK_ID, t);
	}
}

PDDLExpression task_id() : // ADD HDDL
{
    PDDLExpression exp = null;
	PDDLSymbol id = null;
}
{
    (   LOOKAHEAD(2, { !this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)})
	        id = task_id_symbol() {
                exp = new PDDLExpression(PDDLConnective.TASK_ID);
		        exp.setTaskID(id);
		    }
	|   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATIVE_ACTIONS)})
	        exp = timed_task_id()
	) {
	    return exp;
	}

}

PDDLExpression timed_task_id() : // ADD HDDL2.1
{
    PDDLExpression exp = null;
}
{
    (   LOOKAHEAD(2)
            exp=start_task_id()
    |   LOOKAHEAD(2)
            exp=end_task_id()
    ) {
        return exp;
    }
}

PDDLExpression start_task_id() : // ADD HDDL2.1
{
    PDDLSymbol id = null;
    PDDLExpression exp = new PDDLExpression(PDDLConnective.TASK_ID);
}
{
    left_bracket() <START> id = task_id_symbol() right_bracket() {
        id.setTimeSpecifier(PDDLTimeSpecifier.START);
        exp.setTaskID(id);
        return exp;
    }
}

PDDLExpression end_task_id() : // ADD HDDL2.1
{
    PDDLSymbol id = null;
    PDDLExpression exp = new PDDLExpression(PDDLConnective.TASK_ID);
}
{
    left_bracket() <END> id = task_id_symbol() right_bracket() {
        id.setTimeSpecifier(PDDLTimeSpecifier.END);
        exp.setTaskID(id);
        return exp;
    }
}

PDDLExpression htn_constraints_def() : // ADD HDDL
{
    PDDLExpression exp = null;
    PDDLExpression c = null;
}
{
    (   LOOKAHEAD(2)
            exp = empty_and()
    |   LOOKAHEAD(2)
            c = htn_constraint() {
                exp = new PDDLExpression(PDDLConnective.AND);
                exp.addChild(c);
                exp.setBeginLine(c.getBeginLine());
                exp.setBeginColumn(c.getBeginColumn());
                exp.setEndLine(c.getEndLine());
                exp.setEndColumn(c.getEndColumn());
            }
    |   LOOKAHEAD(2)
            exp = and_htn_constraints()
    )
    {
        return exp;
    }
}

PDDLExpression and_htn_constraints() :  // ADD HDDL
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
    PDDLExpression c = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AND> (c = htn_constraint() {
        exp.addChild(c);
    })+ end=right_bracket() {
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression htn_constraint() : // ADD HDDL
{
    PDDLExpression exp = null;
}
{
    (   LOOKAHEAD(2)
            exp = equal_atomic_formula()
    |   LOOKAHEAD(2)
            exp = not_equal_atomic_formula()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = hold_before_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = hold_after_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = hold_between_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = hold_during_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = at_end_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = at_start_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = always_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = at_most_one_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = sometime_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = sometime_before_htn_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.METHOD_CONSTRAINTS)}) // ADD HDDL2.1
            exp = sometime_after_htn_constraint()
    ) {
        return exp;
    }
}

PDDLExpression hold_before_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.HOLD_BEFORE_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <HOLD_BEFORE> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression hold_after_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.HOLD_AFTER_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression effect = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <HOLD_AFTER> id = task_id() effect = effect() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(effect);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression hold_between_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.HOLD_BETWEEN_METHOD_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <HOLD_BETWEEN> id1 = task_id() id2 = task_id() gd = gd() end=right_bracket() {
    exp.addChild(id1);
    exp.addChild(id2);
    exp.addChild(gd);
    exp.setBegin(begin);
    exp.setEnd(end);
    return exp;
}
}

PDDLExpression hold_during_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.HOLD_DURING_METHOD_CONSTRAINT);
    PDDLExpression id1 = null;
    PDDLExpression id2 = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <HOLD_DURING> id1 = task_id() id2 = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id1);
        exp.addChild(id2);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression at_end_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression effect = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AT> <END> id = task_id() effect = effect() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(effect);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression at_start_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AT> <START> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression always_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.ALWAYS_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <ALWAYS> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression at_most_one_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_MOST_ONCE_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <AT_MOST_ONCE> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression sometime_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.SOMETIME_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <SOMETIME> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression sometime_before_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.SOMETIME_BEFORE_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <SOMETIME_BEFORE> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression sometime_after_htn_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.SOMETIME_AFTER_METHOD_CONSTRAINT);
    PDDLExpression id = null;
    PDDLExpression gd = null;
    Token begin = null;
    Token end = null;
}
{
    begin=left_bracket() <SOMETIME_AFTER> id = task_id() gd = gd() end=right_bracket() {
        exp.addChild(id);
        exp.addChild(gd);
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLDerivedPredicate derived_def() :
{
	PDDLNamedTypedList head = null;
	PDDLExpression body = null;
	Token begin = null;
	Token end = null;
}
{
	try {
		left_bracket() <DERIVED>
			head=atomic_formula_skeleton()
			body=gd()
		right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
		PDDLDerivedPredicate axiom = new PDDLDerivedPredicate(head, body);
		axiom.setBegin(begin);
		axiom.setEnd(end);
		return axiom;
	}
}

PDDLAction action_def() :
{
	PDDLSymbol name = null;
	List<PDDLTypedSymbol> parameters = null;
	PDDLExpression preconds = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression effects = new PDDLExpression(PDDLConnective.AND);
	Token begin = null;
	Token end = null;
}
{
	try {
		begin=left_bracket() <ACTION> name=action_name()
			<PARAMETERS> left_bracket() parameters=typed_list(Lexer.VARIABLE) right_bracket()
		    <PRECONDITION> preconds=pre_gd()
		    <EFFECT> effects=effect()
		end=right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
		PDDLAction a = new PDDLAction(name, parameters, preconds, effects);
		a.setBegin(begin);
		a.setEnd(end);
		return a;
	}
}

PDDLAction htn_action_def() :
{
	PDDLSymbol name = null;
	List<PDDLTypedSymbol> parameters = null;
	PDDLExpression preconds = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression effects = new PDDLExpression(PDDLConnective.AND);
    Token begin = null;
    Token end = null;

}
{
	try {
		begin=left_bracket() <ACTION> name=action_name()
			<PARAMETERS> left_bracket() parameters=typed_list(Lexer.VARIABLE) right_bracket()
		    [LOOKAHEAD(2) <PRECONDITION> preconds=pre_gd()]
			[LOOKAHEAD(2) <EFFECT> effects=effect()]
		end=right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
		PDDLAction a =  new PDDLAction(name, parameters, preconds, effects);
		a.setBegin(begin);
        a.setEnd(end);
        return a;
	}
}

PDDLSymbol action_name() :
{
	Token t = token;
}
{
	t=<SYMBOL> {
		return new PDDLSymbol(SymbolType.ACTION, t);
	}
}

PDDLExpression pre_gd() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(3, { this.isRequirement(PDDLRequireKey.PREFERENCES)}) exp=pref_gd()
	|	LOOKAHEAD(2) exp=and_pre_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)}) exp=forall_pre_gd()
	|	LOOKAHEAD(2) exp=empty_or()
	|	LOOKAHEAD(2) exp=gd()
	) {
		return exp;
	}
}

PDDLExpression empty_or() :
{
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() end=right_bracket()
	{
		PDDLExpression or = new PDDLExpression(PDDLConnective.OR);
		or.setBegin(begin);
		or.setEnd(end);
		return or;
	}
}

PDDLExpression empty_and() :
{
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() end=right_bracket()
	{
		PDDLExpression and = new PDDLExpression(PDDLConnective.AND);
		and.setBegin(begin);
        and.setEnd(end);
        return and;
	}
}

PDDLExpression and_pre_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression s;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <AND>
		(s=pre_gd() {
			exp.addChild(s);
		})*
		end=right_bracket()
	{
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression forall_pre_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	List<PDDLTypedSymbol> vars = null;
	PDDLExpression s = null;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			vars=typed_list(Lexer.VARIABLE)
		right_bracket()
		s=pre_gd()
	end=right_bracket()
	{
		exp.setQuantifiedVariables(vars);
		exp.addChild(s);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression pref_gd() :
{
	PDDLSymbol pref_name = null;
	PDDLExpression exp = null;
	Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <PREFERENCE>
		[pref_name=pref_name()]
		exp=gd()
	end=right_bracket() {
		exp.setPrefName(pref_name);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLSymbol pref_name() :
{
	Token t = null;
}
{
	t=<SYMBOL> {
		return new PDDLSymbol(SymbolType.PREFERENCE, t);
	}
}

PDDLExpression effect() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=empty_or()
	|   LOOKAHEAD(2) exp=and_c_effect()
	|	LOOKAHEAD(2) exp=c_effect()
	) {
		return exp;
	}
}

PDDLExpression and_c_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression s = null;
	Token begin = null;
	Token end = null;
}
{
	begin=left_bracket() <AND> (LOOKAHEAD(2) s=c_effect() {
		exp.addChild(s);
	})*
	end=right_bracket()
	{
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression c_effect() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.CONDITIONAL_EFFECTS)}) exp=forall_effect()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.CONDITIONAL_EFFECTS)}) exp=when_con_effect()
	|	LOOKAHEAD(2) exp=p_effect()
	) {
		return exp;
	}
}

PDDLExpression forall_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	List<PDDLTypedSymbol> vars = null;
	PDDLExpression s = null;
	Token begin = null;
	Token end = null;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			vars=typed_list(Lexer.VARIABLE)
		right_bracket()
		s=effect()
	end=right_bracket() {
		exp.setQuantifiedVariables(vars);
		exp.addChild(s);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression when_con_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.WHEN);
	PDDLExpression condition = null;
	PDDLExpression effects = null;
	Token begin = null;
	Token end = null;
}
{
	begin=left_bracket() <WHEN>
		condition=gd()
		effects=cond_effect()
	end=right_bracket() {
		exp.addChild(condition);
		exp.addChild(effects);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression cond_effect() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=and_p_effect()
	|	LOOKAHEAD(2) exp=p_effect()
	) {
		return exp;
	}
}

PDDLExpression and_p_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression s = null;
	Token begin = null;
	Token end = null;
}
{
	begin=left_bracket() <AND> (LOOKAHEAD(2) s=p_effect() {
		exp.addChild(s);
	})*
	end=right_bracket()
	{
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression p_effect() :
{
	PDDLExpression exp = null;
}
{
 	(	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.FLUENTS)
    			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
    			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)}) exp=assign_op()
    	|   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.ACTION_COSTS) }) exp=increase_total_cost()
    	|	LOOKAHEAD(2) exp=literal(Lexer.TERM)
    	) {
    		return exp;
    	}

}

PDDLExpression increase_total_cost() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.INCREASE);
	PDDLExpression op1 = null;
	PDDLExpression op2 = null;
    Token begin = null;
    Token end = null;
}
{
	begin=left_bracket() <INCREASE>
		op1=total_cost()
		op2=numeric_term()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression total_cost() :
{
	Token t;
    Token begin;
    Token end;
}
{
	begin=left_bracket() t=<TOTAL_COST> end=right_bracket() {
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FN_HEAD);
	exp.setSymbol(new PDDLSymbol(SymbolType.FUNCTOR, t));
	exp.setArguments(new ArrayList<PDDLSymbol>());
	exp.setBegin(begin);
	exp.setEnd(end);
	return exp;
}
}

PDDLExpression numeric_term() :
{
	List<PDDLSymbol> tokenList = new ArrayList<PDDLSymbol>();
	PDDLSymbol s = null;
	PDDLExpression exp = null;
}
{
	(   exp=f_head()
    | 	exp=number()
    ) {
		return exp;
	}
}

PDDLExpression assign_op() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=assign()
	|	LOOKAHEAD(2) exp=scale_up()
	|	LOOKAHEAD(2) exp=scale_down()
	|	LOOKAHEAD(2) exp=increase()
	|	LOOKAHEAD(2) exp=decrease()
	) {
		return exp;
	}
}

PDDLExpression assign() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.ASSIGN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <ASSIGN>
		op1=f_head()
		op2=f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression scale_up() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.SCALE_UP);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <SCALE_UP>
		op1=f_head()
		op2=f_exp()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression scale_down() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.SCALE_DOWN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <SCALE_DOWN>
		op1=f_head()
		op2=f_exp()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression increase() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.INCREASE);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <INCREASE>
		op1=f_head()
		op2=f_exp()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression decrease() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.DECREASE);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <DECREASE>
		op1=f_head()
		op2=f_exp()
	end=right_bracket()
	{
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLAction durative_action_def() :
{
	PDDLSymbol name = null;
	List<PDDLTypedSymbol> parameters = null;
	PDDLExpression duration = null;
	PDDLExpression condition = null;
	PDDLExpression effect = null;
	Token begin = null;
    Token end = null;

}
{
	try {
		begin=left_bracket() <DURATIVE_ACTION> name=da_symbol()
			<PARAMETERS>
				left_bracket()
					parameters=typed_list(Lexer.VARIABLE)
				right_bracket()
			<DURATION> duration=duration_constraint()
			<CONDITION> condition=da_gd()
			<EFFECT> effect=da_effect()
		end=right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
		PDDLAction a = new PDDLAction(name, parameters, condition, effect, duration);
		a.setBegin(begin);
		a.setEnd(end);
		return a;
	}
}

PDDLSymbol da_symbol() :
{
	Token t = null;
}
{
	t=<SYMBOL> {
	return new PDDLSymbol(SymbolType.ACTION, t);
}
}

PDDLExpression duration_constraint() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(2) exp=empty_or()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)}) exp=and_simple_duration_constraint()
	|	LOOKAHEAD(2) exp=simple_duration_constraint()
	) {
		return exp;
	}
}
PDDLExpression and_simple_duration_constraint() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=simple_duration_constraint(){
			exp.addChild(child);
		})+
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression simple_duration_constraint() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=d_op()
	|	LOOKAHEAD(2) exp=at_simple_duration_constraint()
	) {
		return exp;
	}
}

PDDLExpression at_simple_duration_constraint() :
{
	PDDLExpression exp = null;
}
{
	(	LOOKAHEAD(3) exp=at_start_simple_duration_constraint()
	| 	LOOKAHEAD(3) exp=at_end_simple_duration_constraint()
	) {
		return exp;
	}
}

PDDLExpression at_start_simple_duration_constraint() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <START>
		child=simple_duration_constraint()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_end_simple_duration_constraint() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <END>
		child=simple_duration_constraint()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression d_op() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2)
			exp=equal_d_op()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
			exp=gequal_d_op()
	| 	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
			exp=lequal_d_op()
	) {
		return exp;
	}
}

PDDLExpression equal_d_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.EQUAL_COMPARISON);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <EQUAL>
		op1=var_duration()
		op2=d_value()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression gequal_d_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_OR_EQUAL_COMPARISON);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <GEQUAL>
		op1=var_duration()
		op2=d_value()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression lequal_d_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_OR_EQUAL_COMPARISON);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <LEQUAL>
		op1=var_duration()
		op2=d_value()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression var_duration() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.TIME_VAR);
	Token t;
}
{
	t=<VAR_DURATION>
	{
		exp.setVariable(new PDDLSymbol(SymbolType.DURATION_VARIABLE, t));
		return exp;
	}
}

PDDLExpression d_value() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=number()
	| 	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)}) exp=f_exp()
	) {
		return exp;
	}
}

PDDLExpression method_duration_constraint() : // ADD HDDL2.1
{
    PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=empty_or()
	|	LOOKAHEAD(2) exp=simple_method_duration_constraint() // ADD HDDL2.1
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)}) // ADD HDDL2.1
            exp=and_simple_method_duration_constraint()
	) {
	    return exp;
	}
}

PDDLExpression and_simple_method_duration_constraint() : // ADD HDDL2.1
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=simple_method_duration_constraint(){
			exp.addChild(child);
		})+
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression simple_method_duration_constraint() : // ADD HDDL2.1
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2)
            exp=equal_method_duration_constraint()
    |	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
             exp=great_method_duration_constraint()
    | 	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
            exp=great_or_equal_method_duration_constraint()
    |   LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
            exp=less_method_duration_constraint()
    | 	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)})
            exp=less_or_equal_method_duration_constraint()
	|	LOOKAHEAD(2) exp=at_simple_duration_constraint()
	) {
		return exp;
    }
}

PDDLExpression equal_method_duration_constraint() : // ADD HDDL2.1
{
  	PDDLExpression exp = new PDDLExpression(PDDLConnective.EQUAL_COMPARISON);
  	PDDLExpression op1, op2;
  	Token begin, end;
}
{
  	begin=left_bracket() <EQUAL>
  		op1=duration()
  		op2=d_value()
  	end=right_bracket() {
  		exp.addChild(op1);
  		exp.addChild(op2);
  		exp.setBegin(begin);
  		exp.setEnd(begin);
  		return exp;
  	}
}

PDDLExpression great_method_duration_constraint() : // ADD HDDL2.1
{
   	PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_COMPARISON);
   	PDDLExpression op1, op2;
   	Token begin, end;
}
{
   	begin=left_bracket() <GREAT>
   		op1=duration()
   		op2=d_value()
   	end=right_bracket() {
   		exp.addChild(op1);
   		exp.addChild(op2);
   		exp.setBegin(begin);
   		exp.setEnd(end);
   		return exp;
   	}
}

PDDLExpression great_or_equal_method_duration_constraint() : // ADD HDDL2.1
{
   	PDDLExpression exp = new PDDLExpression(PDDLConnective.GREATER_OR_EQUAL_COMPARISON);
   	PDDLExpression op1, op2;
   	Token begin, end;
}
{
   	begin=left_bracket() <GEQUAL>
   		op1=duration()
   		op2=d_value()
   	end=right_bracket() {
   		exp.addChild(op1);
   		exp.addChild(op2);
   		exp.setBegin(begin);
   		exp.setEnd(end);
   		return exp;
   	}
}

PDDLExpression less_method_duration_constraint() : // ADD HDDL2.1
{
   	PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_COMPARISON);
   	PDDLExpression op1, op2;
   	Token begin, end;
}
{
   	begin=left_bracket() <LESS>
   		op1=duration()
   		op2=d_value()
   	end=right_bracket() {
   		exp.addChild(op1);
   		exp.addChild(op2);
   		exp.setBegin(begin);
   		exp.setEnd(end);
   		return exp;
   	}
}

PDDLExpression less_or_equal_method_duration_constraint() : // ADD HDDL2.1
{
   	PDDLExpression exp = new PDDLExpression(PDDLConnective.LESS_OR_EQUAL_COMPARISON);
   	PDDLExpression op1, op2;
   	Token begin, end;
}
{
   	begin=left_bracket() <LEQUAL>
   		op1=duration()
   		op2=d_value()
   	end=right_bracket() {
   		exp.addChild(op1);
   		exp.addChild(op2);
   		exp.setBegin(begin);
   		exp.setEnd(end);
   		return exp;
   	}
}

PDDLExpression duration() : // ADD HDDL2.1
{
    PDDLExpression duration;
}
{
    (duration = var_duration() | duration = f_duration()) {
        return duration;
    }
}

PDDLExpression f_duration() : // ADD HDDL2.1
{
    PDDLExpression exp = new PDDLExpression(PDDLConnective.F_TASK_TIME);
    Token f, begin, end;
    PDDLSymbol argument;
}
{
    begin=left_bracket() f=<F_DURATION> argument = task_id_symbol() end=right_bracket() {
        exp.setSymbol(new PDDLSymbol(SymbolType.FUNCTOR, f));
        exp.setArguments(new ArrayList<PDDLSymbol>());
        exp.setBegin(begin);
        exp.setEnd(end);
        return exp;
    }
}

PDDLExpression temporal_simple_method_duration_constraint() : // ADD HDDL2.1
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(3) exp=at_start_simple_method_duration_constraint()
	| 	LOOKAHEAD(3) exp=at_end_simple_method_duration_constraint()
	) {
		return exp;
	}
}

PDDLExpression at_start_simple_method_duration_constraint() : // ADD HDDL2.1
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <START>
		child=simple_duration_constraint()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_end_simple_method_duration_constraint() : // ADD HDDL2.1
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <END>
		child=simple_duration_constraint()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_gd():
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=pref_timed_gd()
	|	LOOKAHEAD(2) exp=and_da_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)})
			exp=forall_da_gd()
	) {
		return exp;
	}
}

PDDLExpression forall_da_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	PDDLExpression child;
	List<PDDLTypedSymbol> typedList;
	Token begin, end;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		child=da_gd()
	end=right_bracket()
	{
		exp.setQuantifiedVariables(typedList);
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression and_da_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=da_gd() {
			exp.addChild(child);
		})*
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression pref_timed_gd() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2)
			exp=timed_gd()
	|	LOOKAHEAD(2, { this.isRequirement(PDDLRequireKey.PREFERENCES)})
			exp=named_pref_timed_gd()
	) {
		return exp;
	}
}

PDDLExpression named_pref_timed_gd() :
{
	PDDLSymbol pref_name = null;
	PDDLExpression exp;
	Token begin, end;
}
{
	begin=left_bracket() <PREFERENCE>
		[pref_name=pref_name()]
		exp=timed_gd()
	end=right_bracket() {
		exp.setPrefName(pref_name);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression timed_gd() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=at_timed_gd()
	|	LOOKAHEAD(2) exp=over_timed_gd()
	) {
		return exp;
	}
}

PDDLExpression over_timed_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.OVER_ALL);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <OVER> <ALL>
		child=gd()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_timed_gd() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(3) exp=at_start_timed_gd()
	|	LOOKAHEAD(2) exp=at_end_timed_gd()
	) {
		return exp;
	}
}

PDDLExpression at_start_timed_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <START>
		child=gd()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_end_timed_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <END>
		child=gd()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_effect() :
{
	PDDLExpression exp;
}
{
	(
		LOOKAHEAD(2)
			exp=and_da_effect()
	| 	LOOKAHEAD(2)
			exp=timed_effect()
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.CONDITIONAL_EFFECTS)})
			exp=forall_da_effect()
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.CONDITIONAL_EFFECTS)})
			exp=when_da_effect()
	| 	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)})
			exp=da_assign_op()

	) {
		return exp;
	}
}

PDDLExpression da_assign_op() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=da_assign()
	|	LOOKAHEAD(2) exp=da_scale_up()
	|	LOOKAHEAD(2) exp=da_scale_down()
	|	LOOKAHEAD(2) exp=da_increase()
	|	LOOKAHEAD(2) exp=da_decrease()
	) {
		return exp;
	}
}

PDDLExpression da_assign() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.ASSIGN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <ASSIGN>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_scale_up() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.SCALE_UP);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <SCALE_UP>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_scale_down() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.SCALE_DOWN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <SCALE_DOWN>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_increase() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.INCREASE);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <INCREASE>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_decrease() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.DECREASE);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <DECREASE>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression when_da_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.WHEN);
	PDDLExpression condition, effect;
	Token begin, end;
}
{
	begin=left_bracket() <WHEN>
		condition=da_gd()
		effect=da_effect()
	end=right_bracket() {
		exp.addChild(condition);
		exp.addChild(effect);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression forall_da_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	List<PDDLTypedSymbol> typedList;
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		child=da_effect()
	end=right_bracket() {
		exp.setQuantifiedVariables(typedList);
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression and_da_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=da_effect() {
			exp.addChild(child);
		})*
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression timed_effect() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2)
			exp=at_a_effect()
	|	LOOKAHEAD(3, {this.isRequirement(PDDLRequireKey.CONTINOUS_EFFECTS)})
			exp=assign_op_t()
	) {
		return exp;
	}
}

PDDLExpression at_f_assign_da() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(3) exp=at_start_f_assign_da()
	|	LOOKAHEAD(3) exp=at_end_f_assign_da()
	) {
		return exp;
	}
}

PDDLExpression at_start_f_assign_da() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <START>
		child=f_assign_da()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}


PDDLExpression at_end_f_assign_da() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <END>
		child=f_assign_da()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_a_effect() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(4) exp=at_start_a_effect()
	|	LOOKAHEAD(4) exp=at_end_a_effect()
	) {
		return exp;
	}
}


PDDLExpression a_effect() :
{
	PDDLExpression exp;
}
{
 	(	LOOKAHEAD(2) exp=f_assign_da()
	|	LOOKAHEAD(2) exp=literal(Lexer.TERM)
	|	LOOKAHEAD(2) exp=when_con_effect()
	|	LOOKAHEAD(2) exp=forall_effect()
	) {
		return exp;
	}
}

PDDLExpression at_start_a_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_START);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <START>
		child=a_effect()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression at_end_a_effect() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AT_END);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AT> <END>
		child=a_effect()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression assign_op_t() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=increase_assign_op_t()
	|	LOOKAHEAD(2) exp=decrease_assign_op_t()
	) {
		return exp;
	}
}

PDDLExpression increase_assign_op_t() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.ASSIGN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <INCREASE>
		op1=f_head()
		op2=f_exp_t()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression decrease_assign_op_t() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.ASSIGN);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <DECREASE>
		op1=f_head()
		op2=f_exp_t()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression f_exp_t() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.F_EXP_T);
	PDDLSymbol continuous_variable_name;
	PDDLExpression child;
	Token begin, end;
}
{
	(	LOOKAHEAD(2)
			begin=left_bracket() <MUL>
				continuous_variable_name=continuous_variable()
				child=f_exp()
			end=right_bracket() {
			    exp.setBegin(begin);
			    exp.setEnd(end);
			    exp.addChild(child);
			    exp.setVariable(continuous_variable_name);
			}
	| 	LOOKAHEAD(2)
			begin=left_bracket() <MUL>
				child=f_exp()
				continuous_variable_name=continuous_variable()
			end=right_bracket()  {
                exp.setBegin(begin);
                exp.setEnd(end);
                exp.addChild(child);
                exp.setVariable(continuous_variable_name);
            }
	| 	LOOKAHEAD(2)
		    continuous_variable_name=continuous_variable() {
		        exp.setBeginLine(continuous_variable_name.getBeginLine());
                exp.setBeginColumn(continuous_variable_name.getBeginColumn());
                exp.setEndLine(continuous_variable_name.getEndLine());
                exp.setEndColumn(continuous_variable_name.getEndColumn());
                exp.setVariable(continuous_variable_name);
		    }
	) {
		return exp;
	}
}

PDDLSymbol continuous_variable() :
{
	Token t;
}
{
	t=<CONTINUOUS_VARIABLE>  {
		return new PDDLSymbol(SymbolType.CONTINUOUS_VARIABLE, t);
	}
}

PDDLExpression f_assign_da() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=da_assign()
	|	LOOKAHEAD(2) exp=da_scale_up()
	|	LOOKAHEAD(2) exp=da_scale_down()
	|	LOOKAHEAD(2) exp=da_increase()
	|	LOOKAHEAD(2) exp=da_decrease()
	) {
		return exp;
	}
}

PDDLExpression f_exp_da() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=da_op()
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.DURATION_INEQUALITIES)}) exp=var_duration()
	|	LOOKAHEAD(2) exp=f_exp()
	) {
		return exp;
	}
}


PDDLExpression da_op() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=da_add_op()
	|	LOOKAHEAD(2) exp=da_substract_op()
	|	LOOKAHEAD(2) exp=da_multiply_op()
	|	LOOKAHEAD(2) exp=da_divide_op()
	) {
		return exp;
	}
}

PDDLExpression da_add_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.PLUS);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <ADD>
	(	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	| 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_substract_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MINUS);
	PDDLExpression op1, op2 = null;
	Token begin, end;
}
{
	begin=left_bracket() <SUB>
		(	LOOKAHEAD(3) (op1=f_head() [op2=f_exp_da()])
	    | 	LOOKAHEAD(3) ([LOOKAHEAD(2) op2=f_exp_da()] op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		if (op2 != null) exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_multiply_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MULTIPLICATION);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <MUL>
	    (	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	    | 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression da_divide_op() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.DIVISION);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <DIV>
	    (	LOOKAHEAD(3) (op1=f_head() op2=f_exp_da())
	    | 	LOOKAHEAD(3) (op2=f_exp_da() op1=f_head()))
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLProblem problem() :
{
}
{
    (   LOOKAHEAD({this.isRequirement(PDDLRequireKey.HIERARCHY)})
            htn_problem()
    |    pddl_problem()
    ) {
    return this.problem;
    }
}

PDDLProblem pddl_problem() :
{
	PDDLSymbol name;
	PDDLSymbol domain;
}
{
	try {
		left_bracket() <DEFINE>
		left_bracket() <PROBLEM>
			name=problem_name()
		right_bracket()
		left_bracket() <P_DOMAIN>
			domain = domain_problem_name() {
                this.problem = new ParsedProblem(name, domain);
            }
		right_bracket()
		[LOOKAHEAD(2) require_def(Lexer.PARSER_PROBLEM)]
		[LOOKAHEAD(2) object_declaration()]
        init()
		goal()
		[LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.CONSTRAINTS)}) pddl_const(Lexer.PARSER_PROBLEM)]
		[LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)}) metric_spec()]
		// [length-spec()] not implemented
		right_bracket()
		<EOF>
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
	{
	    return this.problem;
    }
}

PDDLProblem htn_problem() : // ADD HDDL
{
	PDDLSymbol name;
	PDDLSymbol domain;
	PDDLTaskNetwork taskNetwork;
	List<PDDLTypedSymbol> parameters = new ArrayList<PDDLTypedSymbol>();
}
{
	try {
		left_bracket() <DEFINE>
		left_bracket() <PROBLEM>
			name=problem_name()
		right_bracket()
		left_bracket() <P_DOMAIN>
			domain = domain_problem_name() {
			    this.problem = new ParsedProblem(name, domain);
		    }

		right_bracket()
		[LOOKAHEAD(2) require_def(Lexer.PARSER_PROBLEM)]
		[LOOKAHEAD(2) object_declaration()]
        left_bracket() <HTN>
            [LOOKAHEAD(2) <PARAMETERS> left_bracket() parameters=typed_list(Lexer.VARIABLE) right_bracket()]
            taskNetwork = task_network() {
                taskNetwork.setParameters(parameters);
                this.problem.setInitialTaskNetwork(taskNetwork);
            }
        right_bracket()
		init()
		[LOOKAHEAD(2) goal()]
		[LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)}) metric_spec()]
		right_bracket()
		<EOF>
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
    {
        return this.problem;
    }
}


PDDLSymbol problem_name() :
{ Token t = null; }
{
	t=<SYMBOL> {  return new PDDLSymbol(SymbolType.PROBLEM, t); }
}

PDDLSymbol domain_problem_name() :
{ Token t = null; }
{
	t=<SYMBOL> {  return new PDDLSymbol(SymbolType.DOMAIN, t); }
}

PDDLSymbol domain_name() :
{ Token t = null; }
{
	t=<SYMBOL> { return new PDDLSymbol(SymbolType.DOMAIN, t); }
}

void object_declaration() :
{
	List<PDDLTypedSymbol> typedList = null;
}
{
	try {
		left_bracket() <OBJECTS>
			typedList=typed_list(Lexer.CONSTANT)
		right_bracket() {
			for (PDDLTypedSymbol object : typedList) {
				this.problem.addObject(object);
			}
		}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

void init() :
{
	PDDLExpression exp;
}
{
	try {
		left_bracket() <INIT>
			(LOOKAHEAD(2) exp=init_el() {
				this.problem.addInitialFact(exp);
			})*
		right_bracket()
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}


PDDLExpression init_el() :
{
	PDDLExpression exp;
}
{
	(
		LOOKAHEAD(3, {this.isRequirement(PDDLRequireKey.TIMED_INITIAL_LITERALS)}) exp=timed_literal()
	|	LOOKAHEAD(2) exp=literal(Lexer.CONSTANT)
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.FLUENTS)
			|| this.isRequirement(PDDLRequireKey.NUMERIC_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.OBJECT_FLUENTS)
			|| this.isRequirement(PDDLRequireKey.ACTION_COSTS)}) exp=equal_init_el()
	) {
		return exp;
	}
}

PDDLExpression equal_init_el() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FN_ATOM);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket() <EQUAL>
		op1=constant_f_head()
		op2=number()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression timed_literal() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.TIMED_LITERAL);
	PDDLExpression literal, time;
	Token begin, end;
}
{
	begin=left_bracket() <AT>
		time=number()
		literal=literal(Lexer.CONSTANT)
	end=right_bracket() {
		exp.addChild(time);
		exp.addChild(literal);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}


void goal() :
{
}
{
    left_bracket() <GOAL>
    pddl_goal()
    right_bracket()
}

void pddl_goal() :
{
	PDDLExpression exp = null;
	Boolean goal_utilities = false;
	if (this.isRequirement(PDDLRequireKey.GOAL_UTILITIES)
			&& !this.isRequirement(PDDLRequireKey.PREFERENCES)) {
		this.getRequirements().add(PDDLRequireKey.PREFERENCES);
		goal_utilities = true;
	}

}
{
	try {
		exp=pre_gd() {
			this.problem.setGoal(exp);
			if (goal_utilities) {
				this.getRequirements().remove(PDDLRequireKey.PREFERENCES);
			}
	   	}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}

void pddl_const(int type) :
{
	PDDLExpression conGD;
}
{
	try {
		left_bracket() <CONSTRAINTS>
			conGD=pref_con_gd()
		right_bracket() {
			if (type == Lexer.PARSER_DOMAIN) {
				this.domain.setConstraints(conGD);
			} else {
				this.problem.setConstraints(conGD);
			}
		}
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}
}


PDDLExpression pref_con_gd() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2)
			exp=and_pref_con_gd()
	|	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.UNIVERSAL_PRECONDITIONS)})
			exp=forall_pref_con_gd()
	| 	LOOKAHEAD(2, {this.isRequirement(PDDLRequireKey.PREFERENCES)})
			exp=named_pref_con_gd()
	|	LOOKAHEAD(2)
			exp=con_gd()
	) {
		return exp;
	}
}

PDDLExpression and_pref_con_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.AND);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <AND>
		(LOOKAHEAD(2) child=pref_con_gd() {
			exp.addChild(child);
		})*
	end=right_bracket() {
        exp.setBegin(begin);
        exp.setEnd(end);
		return exp;
	}
}

PDDLExpression named_pref_con_gd() :
{
	PDDLExpression exp;
	PDDLSymbol pref_name = null;
	Token begin, end;
}
{
	begin=left_bracket() <PREFERENCE>
		[pref_name=pref_name()]
		exp=con_gd()
	end=right_bracket() {
		exp.setPrefName(pref_name);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression forall_pref_con_gd() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FORALL);
	List<PDDLTypedSymbol> typedList;
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket() <FORALL>
		left_bracket()
			typedList=typed_list(Lexer.VARIABLE)
		right_bracket()
		child=pref_con_gd()
	end=right_bracket() {
		exp.setQuantifiedVariables(typedList);
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

void metric_spec() :
{
	PDDLExpression exp;
}
{
	try {
		(	LOOKAHEAD(3) exp=maximize()
		| 	LOOKAHEAD(3) exp=minimize()
		) {
          	this.problem.setMetric(exp);
        }
	} catch(Throwable e) {
		this.error(e, token.beginLine, token.beginColumn);
	}

}

PDDLExpression maximize() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MAXIMIZE);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket()
		<METRIC>
		<MAXIMIZE>
		child=metric_f_exp()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression minimize() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MINIMIZE);
	PDDLExpression child;
	Token begin, end;
}
{
	begin=left_bracket()
		<METRIC>
		<MINIMIZE>
		child=metric_f_exp()
	end=right_bracket() {
		exp.addChild(child);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression metric_f_exp() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=op_metric_f_exp()
	|	LOOKAHEAD(2) exp=number()
	|	LOOKAHEAD(2) exp=constant_f_head()
	|	LOOKAHEAD(2) exp=total_time()
	|	LOOKAHEAD(2) exp=violated_pref_exp()
	) {
		return exp;
	}
}

PDDLExpression violated_pref_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.IS_VIOLATED);
	PDDLSymbol pref_name;
	Token begin, end;
}
{
	begin=left_bracket()
		<IS_VIOLATED>
		pref_name=pref_name()
	end=right_bracket() {
		exp.setPrefName(pref_name);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression constant_f_head() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FN_HEAD);
	List<PDDLSymbol> args = new ArrayList<PDDLSymbol>();
	PDDLSymbol functor, argument;
	Token begin, end;
}
{
	begin=left_bracket()
		functor=functor() {
		    exp.setSymbol(functor);
		}
		(LOOKAHEAD(2) argument=constant(){
			args.add(argument);
		})*
	end=right_bracket() {
		exp.setArguments(args);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression total_time() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.FN_HEAD);
	Token f, begin, end;
}
{
	(LOOKAHEAD(3)
		begin=left_bracket() f=<TOTAL_TIME> end=right_bracket() {
		    exp.setBegin(begin);
		    exp.setEnd(end);
		}
| 	LOOKAHEAD(2)
		f=<TOTAL_TIME>) {
			exp.setSymbol(new PDDLSymbol(SymbolType.FUNCTOR, f));
			exp.setArguments(new ArrayList<PDDLSymbol>());
			exp.setBeginLine(f.beginLine);
            exp.setBeginColumn(f.beginColumn);
            exp.setEndLine(f.endLine);
            exp.setEndColumn(f.endColumn);
			return exp;
		}
}

PDDLExpression op_metric_f_exp() :
{
	PDDLExpression exp;
}
{
	(	LOOKAHEAD(2) exp=add_op_metric_f_exp()
	|	LOOKAHEAD(2) exp=substract_op_metric_f_exp()
	| 	LOOKAHEAD(2) exp=multi_op_metric_f_exp()
	| 	LOOKAHEAD(2) exp=div_op_metric_f_exp()
	) {
		return exp;
	}
}

PDDLExpression add_op_metric_f_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.PLUS);
	PDDLExpression op;
	Token begin, end;
}
{
	begin=left_bracket()
		<ADD>
		op=metric_f_exp() { exp.addChild(op); }
		(LOOKAHEAD(2) op=metric_f_exp() {
			exp.addChild(op);
		})+
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression substract_op_metric_f_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MINUS);
	PDDLExpression op1, op2 = null;
	Token begin, end;
}
{
	begin=left_bracket()
		<SUB>
		op1=metric_f_exp()
		[op2=metric_f_exp()]
	end=right_bracket() {
		exp.addChild(op1);
		if (op2 != null) exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}

PDDLExpression div_op_metric_f_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.DIVISION);
	PDDLExpression op1, op2;
	Token begin, end;
}
{
	begin=left_bracket()
		<DIV>
		op1=metric_f_exp()
		op2=metric_f_exp()
	end=right_bracket() {
		exp.addChild(op1);
		exp.addChild(op2);
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}


PDDLExpression multi_op_metric_f_exp() :
{
	PDDLExpression exp = new PDDLExpression(PDDLConnective.MULTIPLICATION);
	PDDLExpression op;
	Token begin, end;
}
{
	begin=left_bracket()
		<MUL>
		op=metric_f_exp() { exp.addChild(op); }
		(LOOKAHEAD(2) op=metric_f_exp() {
			exp.addChild(op);
		})+
	end=right_bracket() {
		exp.setBegin(begin);
		exp.setEnd(end);
		return exp;
	}
}
